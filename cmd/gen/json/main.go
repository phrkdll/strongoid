package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

const methodTemplate = `// Code generated by strongoid; DO NOT EDIT!
package {{ .Package }}

import "github.com/phrkdll/strongoid"

{{ range .Types }}
func (t {{ . }}) MarshalJSON() ([]byte, error) {
	return strongoid.Id[int64](t).MarshalJSON()
}

func (t *{{ . }}) UnmarshalJSON(data []byte) error {
	return (*strongoid.Id[int64])(t).UnmarshalJSON(data)
}
{{ end }}
`

type templateData struct {
	Package string
	Types   []string
}

func main() {
	dir := "." // aktuelles Verzeichnis
	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, dir, nil, 0)
	if err != nil {
		fmt.Println("parse error:", err)
		os.Exit(1)
	}

	var pkgName string
	var foundTypes []string

	for name, pkg := range pkgs {
		pkgName = name // use directory name as package name
		for _, f := range pkg.Files {
			for _, decl := range f.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					continue
				}
				for _, spec := range genDecl.Specs {
					ts, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					// look for underlying type expressions
					ident, ok := ts.Type.(*ast.IndexExpr)
					if !ok {
						continue
					}
					// check if base type is strongoid.Id
					sel, ok := ident.X.(*ast.SelectorExpr)
					if !ok {
						continue
					}
					if sel.Sel.Name != "Id" {
						continue
					}
					pkgIdent, ok := sel.X.(*ast.Ident)
					if !ok || pkgIdent.Name != "strongoid" {
						continue
					}
					// matched: type MyType strongoid.Id[...]
					foundTypes = append(foundTypes, ts.Name.Name)
				}
			}
		}
	}

	if len(foundTypes) == 0 {
		fmt.Println("No strongoid.Id-based types found.")
		return
	}

	// write generated file
	f, err := os.Create("generated_id_json.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	tmpl := template.Must(template.New("json").Parse(methodTemplate))
	tmpl.Execute(f, templateData{
		Package: pkgName,
		Types:   foundTypes,
	})

	fmt.Println("Generated for types:", strings.Join(foundTypes, ", "))
}
